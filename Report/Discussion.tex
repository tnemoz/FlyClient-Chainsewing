In this chapter, we aim at pointing out what remains unclear in our mitigation and implementation. This chapter's goal is to highlight some problems our implementation is suffering from that we did not manage to solve.

\paragraph{The lack of a verifiable source of randomness.} As mentioned earlier, both the original \FC\ protocol and our implementation lacks a verifiable source of randomness they could use to perform their random sampling. Even though we allowed our implementation to be interactive, we did not manage to find a source of randomness which is:

\begin{itemize}
    \item \textbf{verifiable}, which means that either the client provides the prover with the block to sample, or is able to verify that the blocks the prover provided him with are the ones it would have asked in a case of a non-interactive protocol;
    \item \textbf{efficient}, which means that it is accessible within a short period of time after having requested it;
    \item \textbf{non-predictable or subject to influence from another source}, which is crucial since we don't want the adversary to be able to trigger the verification only whenever they know that they won't get caught. 
\end{itemize}

As of today, it remains unclear whether it is possible to have such a source of randomness, be it in the case of a light client or in the case of a cross-chain relay.

\paragraph{The two provers model.} As specified in the original \FC\ paper and in the Superblock NiPoPoWs paper \cite{\FCCite, \NipoCite}, our implementation focuses on distinguishing a dishonest prover from a honest one. In a real-world example however, it can be easy for an adversary to own the two provers. There is no way we can mitigate this situation, except by connecting to more provers, hoping that at least one of them are going to be honest. The original \FC\ protocol is also subject to this problem. Mitigating this problem is complicated, since we would have to define what can the client reasonably trust to mitigate it. For instance, an SPV client only needs to know the length of the honest chain not to be fooled by an adversary. If it doesn't have access to this information however, it has no way to distinguish a dishonest prover from an honest one.

If the original \FC\ protocol, deployed as a soft or hard fork, has access to the length of the main chain, then it can distinguish honest provers from dishonest ones even if it only connects to dishonest miners (assuming it always perform the random sampling). This is not true anymore with our implementation. Even if the client knows from a trusted source the length of the main chain, as long as the two provers collaborate, there's nothing our implementation can do, since it is based on comparing the proofs provided by the provers

\paragraph{The impossibility to perform the \FC\ random sampling on a cross-chain setting.} As a consequence of the fact that our implementation is a cross-chain relay between the Bitcoin blockchain and the Ethereum one, it is not possible for us to store the data necessary to perform \FC's random sampling, that is the Bitcoin cumulated difficulty. It is possible to deny the impact of the variable difficulty on the random sampling, but \citeauthor{\FCCite} showed in \cite{\FCCite} that it may lead to other attacks on the protocol. Hence, it is not possible to perform the \FC\ protocol once the client has found out that there is no merging block. Enabling it would allow a more efficient client, way less interactive than the one we have implemented and hence, faster and cheaper.

\paragraph{Migrating from a velvet fork to a soft fork.} It is possible, if a majority of the miners agree, that a velvet fork mutates into a soft fork. This would be the case if, for instance, the interlink data was placed in the coinbase field or in an \texttt{OP\_RETURN} transaction in every block mined by up-to-date miners. While our implementation would still work, implementing the original \FC\ protocol to run on this soft fork would allow to verify transactions inclusion in a non-interactive way. Indeed, even though our implementation is as secure and efficient as \FC\, it is interactive, because it has been designed to implement \FC\ when deployed as a velvet fork. Hence, if the protocol rules were to be updated from a velvet fork to a soft fork, our implementation shouldn't be used anymore.

\paragraph{Bad incentives on gas price.} The way our implementation is made gives bad incentives to provers. Indeed, the prover that calls \texttt{getNext} will pay a higher gas price than the other, since the next block will be computed, then cached. While a potential countermeasure would be to penalise the other prover by making them do the computations once again, we think it is a bad way of correcting this problem. A solution to this problem should rather focus on how to reduce the gas costs of the first prover.