\documentclass[11pt]{report}

\newcommand{\reporttitle}{Don't Trust, Verify! Cryptography and Games for Cross-Blockchain Payments (Centre for Cryptocurrency Research and Engineering)}
\newcommand{\reportauthor}{Tristan Nemoz}
\newcommand{\supervisor}{Alexei Zamyatin}
\newcommand{\degreetype}{Computing (Security \& Reliability)}

\input{includes} % Provides packages
\input{notation} % Provides shorthands

\date{September 2020}

\begin{document}
    \input{titlepage}
    
    \pagenumbering{roman}
    \clearpage{\pagestyle{empty}\cleardoublepage}
    \setcounter{page}{1}
    \pagestyle{fancy}
    
    \begin{abstract}
        As an alternative to Simplified Payment Verification \cite{Bitcoin}, a new type of blockchain client emerged: \textit{superlight} clients, also called \textit{sublinear} clients. These alternatives, such as \FC\ \cite{\FCCite} or Superblock \cite{\NipoCite} aim at reducing the number of block headers to send to a verifier to prove the inclusion of a transaction within a blockchain. Specifically, the size of the proofs grows logarithmically with the size of the main chain, while SPV clients proofs grow linearly with the size of the chain. However, it is not clear yet how such an alternative could be deployed on an already existing chain. A convenient way, called a velvet fork \cite{Velvet} is considered as a viable method to do so.
        
        We present a novel kind of attack, called the \textit{chain-sewing} attacks. Initially imagined by Andrianna Polydouri and Dionysis Zindros against Superblock clients deployed as a velvet fork, we show that a similar attack can be run against \FC\ when deployed as a velvet fork and propose countermeasures to this attack.
    \end{abstract}

    \cleardoublepage
    
    \fancyhead[RE,LO]{\sffamily {Table of Contents}}
    \tableofcontents 

    \clearpage{\pagestyle{empty}\cleardoublepage}
    \pagenumbering{arabic}
    \setcounter{page}{1}
    \fancyhead[LE,RO]{\slshape \rightmark}
    \fancyhead[LO,RE]{\slshape \leftmark}
    
    \chapter{Introduction}
        In the original Bitcoin whitepaper \cite{Bitcoin}, \citeauthor{Bitcoin} proposed a simple method to verify the presence of a transaction within a Proof of Work blockchain called Simplified Payment Verification (SPV). While this method significantly reduces the amount of data a peer has to store to verify such a thing, it is not scalable. Indeed, as of June 2020, using this method to verify the presence of a transaction within the Ethereum blockchain requires storing approximately \num{10000000} headers \cite{Etherscan}, each of which requires \SI{508}{\byte} of storage \cite{\FCCite}. Hence, this method would require approximately \SI{4.73}{\gibi\byte} of storage, and grows linearly with the size of the main chain. Furthermore, the existence of multi-currency wallets worsens the problem, a \textit{client} having by definition low storage and memory capacities.
        
        In order to overcome this problem, two approaches, so-called \textit{superlight} blockchain clients or \textit{sublinear} light clients, have been proposed: Superblock \cite{\NipoCite} and \FC\ \cite{\FCCite}. Since the former does not take into account the variable difficulty of the Bitcoin protocol, the latter uses a different approach to handle this problem.
        
        However, both these protocols require the addition in the header of a block of a new data field: the MMR root \cite{\FCCite} for \FC\ and the previous \textit{superblocks} level for Superblock. In order to implement those, it is thus necessary to fork the current protocol to add this data field if it is not present. A convenient way to do this, considered by the authors of \FC, is to deploy it as a velvet fork \cite{Velvet}. While they claim the security of the \FC\ protocol when deployed as such, a new type of attack called the \textit{chain-sewing} attacks, discovered by the authors of the Superblock protocol, allows an adversary to perform a double-spend transaction with non-overwhelming probability of failure.
        
        In this thesis, we aim to describe formally a \textit{chain-sewing} attack on the \FC\ protocol when deployed as a velvet fork, to improve this protocol to make it resistant to this kind of attacks and finally to implement it as a chain relay, similarly to BTC-Relay \cite{BTCRelay}.
        
        \paragraph{Blockchains and Simplified Payment Verification clients.} A \textit{block} is a data structure composed of two parts: the body and the header. The body contains transactions, which are actually arrays of inputs and outputs that can be hashed using SHA-256 \cite{SoK}. A block header contains metadata, including but not limited to the block version, the previous block header hash, the Merkle Tree root or a nonce, potentially used as a Proof of Work \cite{BitcoinHeader}. That said, a \textit{blockchain} is the data structure linking blocks together, using the previous block header hash and the nonce.
        
        Simplified Payment Verification (SPV) has been introduced in the original Bitcoin whitepaper \cite{Bitcoin} as a protocol to verify the inclusion of a transaction within the main chain efficiently. The argument back then was that a Bitcoin block header is \SI{80}{\byte} big, while the total block size is in average \SI{1.284}{\mega\byte} as of July 2, 2020 and shows a general increase throughout the years \cite{BitcoinSize}. The SPV protocol requires to store every block header in the chain, or at least their nonce, reference to the previous block header and Merkle Tree root. These information gathered, the size of the proof of the inclusion of a transaction is logarithmic in the number of transactions included within the block which contains the transaction we're interested in. However, if the client does not have a copy of the chain, it has to download and store every block header present in the chain, making the size of the proof growing linearly with the length of the blockchain.
        
        Two types of nodes are to be considered, according to \cite{SoKDistributed}: full nodes, who owns a local copy of the blockchain, and clients. Not only clients does not have a local copy of the blockchain, but they are generally also limited in memory and storage.
        
        \paragraph{\textit{Superlight} clients.} In the light of the need of more efficient protocol providing proofs of inclusion of transaction within a chain, two methods were proposed: Superblock, also called Non-Interactive Proofs of Proof-of-Work (NIPoPoWs) \cite{\NipoCite} and \FC\ \cite{\FCCite}. Both these protocols aim to provide such proofs whose size grows logarithmically with the total length of the chain, while SPV provides proofs whose size grows linearly with this length.
        
        The idea behind the Superblock protocol is to use \textit{superblocks}, that are blocks that appear less frequently than \enquote{normal} blocks. \textit{Superblocks} can be categorized in several levels: \textit{superblocks} of level 1 are twice less frequent than \enquote{normal} blocks, that are \textit{superblocks} of level 0. More generally there is in average a factor \(2^i\) between the number of \textit{superblocks} of level \(i\) and the number of \enquote{normal} blocks. The Superblock method samples mostly \textit{superblocks}, which allows for proofs growing polylogarithmically with the size of the chain. However, an interlink data referencing superblocks must be used for the protocol to run. Furthermore, as the \FC\ authors highlighted: \blockquote{It isnâ€™t clear how to modify the super-block based protocols to handle the variable difficulties} \cite{\FCCite}.
        
        \FC\ uses a different approach. The principle is to make the prover commits on its chain before the protocol, using Merkle Mountain Range \cite{\FCCite}. Then, \citeauthor{\FCCite} determined an optimized sampling strategy which samples a fake block if the adversary created one with overwhelming probability. The committing they was forced to make prevents them from providing a valid block in lieu of a fake block. The number of blocks sampled by a prover using the \FC\ protocol grows logarithmically with the size of the chain. \FC\ uses this sampling to verify that the adversary effectively owns a copy of the main chain. Once this is determined, it asks for a proof of inclusion of the block containing the transaction it is interested in, along with a Merkle Proof, as used in the SPV protocol. Just like the Superblock protocol, \FC\ also requires the presence of an additional interlink data, which is the Merkle Mountain Range root, often used throughout the protocol. However, unlike Superblock, \FC\ has been designed to work on a chain with variable difficulty.
        
        \paragraph{Velvet forks.} Changing a protocol rules, like adding the interlink data for instance, traditionally requires either a hard fork or a soft fork. In the case of a hard fork, adding this interlink data would mean changing every block already mined to add the interlink data to them. In the case of a soft fork, the interlink data would be added only to the most recent blocks. In both cases, it assumes that a majority of nodes in the network has adopted the new protocol.
        
        However, a more novel fork strategy may be more convenient for this case: the velvet fork, that has been described in \cite{Velvet}. The principle is that upgraded nodes mine blocks according to the new protocol but which are still valid regarding to the old protocol. By doing so, there is no need for a majority to adopt the new protocol, as long as \FC\ can be adapted to run with blocks mined by non-upgraded nodes, which the \FC\ authors have done in \cite{\FCCite}. However, this incurs an increase in the size of the proofs, although they are still growing logarithmically with the size of the chain. Furthermore, contrarily to a soft or a hard fork where the interlink data has to be valid to be accepted by the consensus, nothing prevents an adversary from putting arbitrary data in the interlink data field when \FC\ is deployed as a velvet fork, since the block would still be considered valid by the old protocol. It thus gives the adversary a potential way to fool the client.
        
        \paragraph{Our contribution.} We summarize our contributions by the following:
        
        \begin{description}
            \item[\textit{Chain-sewing attacks}.] We formalize the concept of \textit{chain-sewing} attack on \FC\ when deployed as a velvet fork on an existing blockchain. We compute the probability of an adversary succeeding in running this attack if \FC\ is deployed as described in \cite{\FCCite}.
            \item[\FC\ improvement.] We design an improvement to the \FC\ protocol to make it resistant to \textit{chain-sewing} attacks while keeping its efficiency.
            \item[\FC\ implementation.] We implement \FC\ as a chain relay on the Ethereum blockchain using Vyper \cite{Vyper}, mimicking the BTC-relay \cite{BTCRelay} chain relay.
        \end{description}

    \chapter{Background}
        In this section, we aim to describe previous works which will then be used as a basis to start from to solve the problematic of this project.
        \section{The principles of a blockchain}
            \subsection{Definition of a PoW blockchain}
                It is necessary to firstly describe what a blockchain actually is, since this is the central object we will be working on.
                
                Blockchains, and more specifically the Bitcoin one, were introduced in 2007 by \citeauthor{Bitcoin} \cite{Bitcoin}. Their goal was to design a payment system trusted by the users without the need of a centralized authority such as a bank. In order to do this, they replaced the trust the users had in the centralized authority with cryptographic proofs.
                
                First of all, let us describe what a block is. A Block is a data structure organized in two parts: the header of the block and the transactions of the block \cite{BitcoinHeader}. Let us begin by describing what transactions are.
                
                An user of the Bitcoin blockchain possesses a public/private key pair. While the private key is needed to ensure the emitter of a transaction is the one they claim they are, the public key (or more precisely, its hash) is the address of this user \cite{BitcoinTX}. A transaction corresponds to one array containing the inputs and one containing the outputs \cite{SoK}. Crucially, this means that a transaction can be hashed to uniquely identify it. Transactions are further described in \autoref{subsec:txs}.
                
                The block header contains what can be seen as metadata of the block, like the block version, the previous block header hash, etc. Some information are more important than the others however. These information are the previous block header hash, the Merkle Tree root, the current difficulty and a nonce. While the transactions within a block define the money transfers between the users, the block header is used to ensure the security of the protocol. The fundamental concept of a PoW blockchain is to trust the chain on which most of the computational power was spent. All four of these block header fields are meant to be used to solve this problem: the first three ones (along with the transactions within the block and their sorting) define a problem that a user has to solve, the last one is the proof that computational power was actually spent on this block.
                
                This problem is the following: given the previous block header hash \(p_h\) and the other data to be put in the header, like the Merkle Tree root for instance, one must find a nonce \(N\) such that:
                
                \[H\left(p_h\middle|\text{other data}\middle|N\right)\leqslant T\]
                
                where \(H\) is a hash function (SHA-256 for Bitcoin \cite{SoK}) and \(T\) is \(2^{d}\), \(d\) being the current difficulty of the network \cite{PoDL}. The best approach to find such a nonce is bruteforce \cite{PoDL}, that is testing all the possibilities until one finds a correct one. Hence, finding a solution to this problem proves that computational power was spent on its solve. The Proof of Work (PoW) is then defined as the nonce. Note that since everyone has access to the previous block header, the current difficulty of the network and the block's content, including its header, everyone can also verify the PoW of the block and potentially reject it if does not solve the problem.
                
                Since one trusts only blocks with valid PoW, it means that as long as more than half of the users cooperate according to the rules, then an adversary cannot create another chain as long as the main chain without putting blocks with invalid PoW. Such blocks will be called fake blocks. Hence, even though each user does not trust anyone, this system manages to make payments between user without a centralized authority.
                
                Two problems are to be immediately tackled however:
                
                \begin{itemize}
                    \item nothing incentivizes an user to try to solve the problem;
                    \item an user has no funds when they create a public/private key pair.
                \end{itemize}
                
                Both these problems are solved by creating funds and transferring them to the one who solved the problem. By doing so, each user is incentivized to find the solution to the problem rather than to wait for it, and the creation of funds enables more users to perform money transfer once they have received some. This is further described in \autoref{subsec:txs}.
                
                Now that blocks have been defined, we can define what a \textit{blockchain} is. A blockchain is a data structure storing blocks. We design by blockchain the sequence of blocks linked together via their reference to the previous block header hash, just as a linked list. Blockchains are believed to be append-only: once a block has been mined, it is not possible to remove it from the chain. However, it does not mean that this block will be accepted by the consensus. This situation is explained more in details in \autoref{subsec:backbone}. Furthermore, it may be possible under very exceptional circumstances that the consensus chooses to fork the main chain, deleting \textit{de facto} the blocks that were mined after the fork point. This happened because of the DAO hack for instance \cite{DAO}.
            
            \subsection{Bitcoin transactions}
                \label{subsec:txs}
                In the original version of Bitcoin presented in \cite{Bitcoin}, there  were two kinds of different transactions: common transactions and coinbase transactions. Let us begin by describing the former.
                
                A common transaction takes as an input the output of a one or several previous transactions, be they coinbase or common. Such outputs are called unspent transaction output (UTXO) \cite{Survey}. A transaction can have several outputs, each to a different recipient. A fundamental rule has to be respected though: the sum of the inputs of a transaction has to be strictly greater than the sum of its outputs. Two reasons justify this. First of all, it is not allowed to spend more coins that one owns. The second reason is that each transaction induces a fee, which then goes to the miner of the block, that is the one who found the problem solution. A representation of two transactions can be found on \autoref{figure:txs}. Note that this representation does not take into account the fees. Furthermore, note that the transactions inputs are to be of the same emitter, since they can only use their own coins to pay, that is their own UTXOs.
                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}[thick,scale=0.8, every node/.style={transform shape}]
                        \node (utxo1) at (0, 1) {\(\text{UTXO}_1\) (User A, 1 BTC)};
                        \node (utxo2) at (0, -1) {\(\text{UTXO}_2\) (User A, 2 BTC)};
                        \node (utxo3) at (0, -3) {\(\text{UTXO}_3\) (User B, 1 BTC)};
                        \node[right=of utxo1] (middle) {};
                        \node[right=of middle] (output) {};
                        \node[draw=none] (middleoutput) at ($(middle) - (0, 1)$) {};
                        \node[right=of middleoutput] (output2) {Output 2 (User B, 1 BTC)};
                        \node (output1) at ($(output2) + (0, 2)$) {Output 1 (User A, 0.5 BTC)};
                        \node (output3) at ($(output2) + (0, -2)$) {Output 3 (User C, 1.5 BTC)};
                        \node[right=of output2,draw=none] (newinputtemp) {};
                        \node[draw=none] (newinput1) at ($(newinputtemp) + (0, 1)$) {};
                        \node[draw=none] (newinput2) at ($(newinputtemp) + (0, -1)$) {};
                        \node[right=of newinput1] (result1) {Output 4 (User A, 1.5 BTC)};
                        \node[right=of newinput2] (result2) {Output 5 (User B, 0.5 BTC)};
                        
                        \draw (utxo1) -- ($(middle)$);
                        \draw (utxo2) -| ($(middle)$);
                        \draw ($(middleoutput)$) |- (output1);
                        \draw ($(middleoutput)$) -- (output2);
                        \draw ($(middleoutput)$) |- (output3);
                        \draw (utxo3) -| ($(newinput2)$);
                        \draw (output2) -| ($(newinput1)$);
                        \draw ($(newinput1)$) -- ($(newinput2)$);
                        \draw ($(newinput1)$) -- (result1);
                        \draw ($(newinput2)$) -- (result2);
                    \end{tikzpicture}
                    \caption{An example of two transactions}
                    \label{figure:txs}
                \end{figure}
                
                The second kind of transaction are coinbase transactions \cite{Bitcoin}. They are special in the sense that they don't take any UTXO in input. A coinbase transaction is the transaction rewarding a miner for having mined a block. This is what incentivizes the miner to behave accordingly to the protocol \cite{Bitcoin, SoK}, and the only way to create coins.

            \subsection{Simplified Payment Verification}
                That said, is there a more efficient way to verify the presence of a transaction within the chain than storing every block? In order to solve this problem, \citeauthor{Bitcoin} proposed a method: the Simplified Payment Verification \cite{Bitcoin}.
                
                Every block header contains what is called the Merkle Tree root of the transactions it contains. A Merkle Tree is a balanced binary tree such that each leaf contains a hash, and each node that is not a leaf contains the hash of the concatenation of its children. An example of the construction of such a tree is given in \autoref{figure:merkleconstruct}, where \(|\) denotes concatenation and \(H\) is a cryptographic hash function that can be applied to a transaction.
                
                \begin{figure}[ht]
                    \centering
                    \begin{forest}
                        [Merkle Tree root
                            [\(H\left(H\left(\text{TX}_1\right)\middle|H\left(\text{TX}_2\right)\right)\)
                                [\(H\left(\text{TX}_1\right)\)[\(\text{TX}_1\)]]
                                [\(H\left(\text{TX}_2\right)\)[\(\text{TX}_2\)]]
                            ]
                            [\(H\left(H\left(\text{TX}_3\right)\middle|H\left(\text{TX}_4\right)\right)\)
                                [\(H\left(\text{TX}_3\right)\)[\(\text{TX}_3\)]]
                                [\(H\left(\text{TX}_4\right)\)[\(\text{TX}_4\)]]
                            ]
                        ]
                    \end{forest}
                    \caption{A Merkle Tree with four transactions}
                    \label{figure:merkleconstruct}
                \end{figure}
                
                Such a tree can be used to provide efficient proofs that a given hash is included within it. Indeed, let us consider the Merkle Tree depicted in \autoref{figure:merkleconstruct} and let us assume that one wants a proof that \(\text{TX}_2\) belongs to this Merkle Tree, given that they know \(H\left(\text{TX}_2\right)\) and the Merkle Tree root. The prover would give them \(H\left(\text{TX}_1\right)\) and \(H\left(H\left(\text{TX}_3\right)\middle|H\left(\text{TX}_4\right)\right)\). The verifier would then check whether the hashes they know \enquote{hash up} to the Merkle Tree root.
                
                Note that it is impossible for an adversary to fake a proof of the inclusion of a transaction. Indeed, they would have to find \(h_2\) such that, given a hash \(h_1\) that they define:
                
                \[H\left(h_1\middle|h_2\right)=\text{Merkle Tree root}\]
                
                holds, which is believed to be computationally infeasible because of the pre-image resistance of \(H\).
                
                Putting things together, the Simplified Payment Verification proposed by \citeauthor{Bitcoin} consists in storing only the block headers and the transactions one is interested in, so that Merkle Tree proofs can be used.

            \subsection{The Bitcoin backbone protocol}
                \label{subsec:backbone}
                Now that the main principles of a PoW blockchain have been described, we will describe the Bitcoin backbone protocol \cite{Backbone}. The Bitcoin backbone protocol formally describes the Bitcoin protocol and defines important properties and concepts for formal analysis of Bitcoin-based protocols. We won't go into details here since we will explicitly state our model and assumptions when proving our results. However, two important definition are given: \textit{persistence} and \textit{liveness}.
                
                \begin{Definition}[Persistence \cite{Backbone}]
                    There exists some natural number \(k\) such that, if \(k\) blocks are mined on top of a certain block, this block will be included in the local blockchain of every honest node with overwhelming probability and will stay on the blockchain permanently.
                \end{Definition}
                
                In order to understand this definition, it is necessary to recall that network assumptions are to be made. It is very likely that two miners attempt and succeed to mine the same block in a short period of time. Note that this can't be the exact same block, since the coinbase transaction for instance is different. This corresponds to the situation depicted in \autoref{figure:fork}, where \(G\) represents the Genesis block, a snake line represents an arbitrary number of blocks and a straight line represents a link between two consecutive blocks. 
                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}[decoration={snake}]
                        \node[block] (G) {};
                        \node[below of=G] {$G$};
                        \node[block, right=of G] (c) {};
                        \node[below of=c] {$c$};
                        \node[block, above right=of c] (cprime1) {};
                        \node[below of=cprime1] {$(c+1)'$};
                        \node[block, below right=of c] (c1) {};
                        \node[below of=c1] {$c+1$};
                        
                        \path[draw, decorate] (G) -- (c);
                        \path[draw] (cprime1.west) -- (c.north);
                        \path[draw] (c1.west) -- (c.south);
                    \end{tikzpicture}
                    \caption{A fork occuring on the blockchain}
                    \label{figure:fork}
                \end{figure}
                
                In this case, both the miners will contact their connected peers in the network to inform them about this new block. From then, other miners will begin to work either on \(c+1\) or on \((c+1)'\). Note that a node that have heard of \(c+1\) already will not consider \((c+1)'\), since it does not add length to the chain they already know.
                
                It is possible that once again, the miners mine nearly at the same time, even though that's unlikely. Still, there will be a point where the period between the two mined blocks will be large enough for the piece of information to propagate through the network. The situation is depicted in \autoref{figure:acceptedfork}.
                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}[decoration={snake}]
                        \node[block] (G) {};
                        \node[below of=G] {$G$};
                        \node[block, right=of G] (c) {};
                        \node[below of=c] {$c$};
                        \node[block, above right=of c] (cprime1) {};
                        \node[below of=cprime1] {$(c+1)'$};
                        \node[block, below right=of c] (c1) {};
                        \node[below of=c1] {$c+1$};
                        \node[block, right=of cprime1] (cprime2) {};
                        \node[below of=cprime2] {$(c+2)'$};
                        \node[block, right=of c1] (c2) {};
                        \node[below of=c2] {$c+2$};
                        \node[block, right=of c2] (c3) {};
                        \node[below of=c3] {$c+3$};
                        
                        \path[draw, decorate] (G) -- (c);
                        \path[draw] (cprime1.west) -- (c.north);
                        \path[draw] (c1.west) -- (c.south);
                        \path[draw] (cprime1.east) -- (cprime2.west);
                        \path[draw] (c1.east) -- (c2.west);
                        \path[draw] (c2.east) -- (c3.west);
                    \end{tikzpicture}
                    \caption{The consensus adopts a fork}
                    \label{figure:acceptedfork}
                \end{figure}
                
                Starting from here, the majority of the nodes will now consider \(c+3\) since it lies within a longer blockchain than \((c+2)'\). This implies that a mined block is not necessarily part of the main chain. Hence, the \textit{persistence} definition of a blockchain states that if a certain number of blocks have been mined on top of a block according to the blockchain of a honest node, then it is quite certain that it will stay in the main chain forever.
                
                The second important definition given by the Bitcoin backbone protocol is \textit{liveness}.
                
                \begin{Definition}[Liveness \cite{Backbone}]
                    A transaction originating from a honest node will eventually be part of a block whose depth in the blockchain is greater than \(k\).
                \end{Definition}

                The liveness property ensures that every transaction issued by a honest node will eventually be considered permanent by all the honest player, given that the blockchain is also \textit{persistent}. Furthermore, \citeauthor{Backbone} showed that if we assume a high network synchronicity, that is, if we assume that the time taken to mine a block is much greater than the time taken to propagate the information throughout the network, then the Bitcoin blockchain has the \textit{persistence} and \textit{liveness} properties, given that an adversary does not own more than 50\% of the total computational power of the network.

        \section{\textit{Superlight} blockchain clients}
            The limitations in both storage and performance of clients led to the creation of novel methods to prove the inclusion of transactions within the chain. We consider two different types of nodes, as in \cite{SoKDistributed}: full nodes, who run a full copy of the blockchain, and clients, who don't.
            
            In this context, two solutions were proposed: Superblock \cite{\NipoCite} and \FC\ \cite{\FCCite}. Since \FC\ is often viewed as an improvement of Superblock, we will provide an overview of the Superblock protocol in order to introduce \FC\ later.
            \subsection{Superblock}
                The Superblock protocol \cite{\NipoCite} uses \textit{superblocks} to build its proofs. As a recall, for a block to be valid, a certain hash \(h\) must hold \(h\leqslant2^{d}\), where \(d\) is the current difficulty of the network. Then, a superblock of level \(i\) are the blocks for which this hash verifies \(h\leqslant2^{d-i}\). For instance, every valid block is a superblock of level 0 and there are in average half as much superblocks of level 1 as there are valid blocks.
                
                Superblock makes use of these statistics in order to determine whether the number of superblocks in an adversary's chain is sufficiently average or not. To do so, the provers can build proofs according to their chains, and the verifier can compare proofs using an operator defined in \cite{\NipoCite}.
                
                However, Superblock suffers from a very important problem: since \textit{superblocks} level and frequencies directly depends on the current difficulty of the network, further work has to be done to adapt it to blockchains with variable difficulty, such as Bitcoin or Ethereum.               
                Since this problem was not tackled in the original Super block paper \cite{\NipoCite}, the \FC\ alternative is viewed as an improvement of Superblock \cite{NipoVsFC}. Still, \citeauthor{\NipoCite} defined in their paper the model of provers and verifiers which is used by \FC.
                
                \begin{Definition}[The prover and verifier model \cite{\NipoCite}]
                    A client that wants to check the presence of a transaction within a chain is \textit{the verifier}. The nodes it connects to are \textit{the provers}. We make the assumption that the client connects to at least one honest prover.
                    
                    For an interactive protocol, several exchanges are needed between the verifier and the prover, which isn't the case for a non-interactive protocol, such as Superblock or \FC.
                    
                    If the verifier is provided with several chains of different lengths it goes for the longest claimed chain first.
                \end{Definition}

                
            \subsection{\FC}
                The main drawback of the Superblock protocol is that it breaks when deployed on a system with variable difficulty, which is the case for most (if not all) of PoW blockchains. Indeed, superblocks are directly linked to the current difficulty of the network, since a bigger difficulty would change the level of all superblocks.
                
                In order to cope with this problem, the \FC\ protocol has been designed \cite{\FCCite}. Just like the Superblock protocol, the idea is to perform a random sampling of the chain and to add an interlink data within the blocks to perform proofs of inclusion. This interlink data, in the case of \FC, is called the Merkle Mountain Range root.
                \subsubsection{Merkle Mountain Range}
                    A Merkle Mountain Range (MMR) \cite{\FCCite} is very similar to a Merkle Tree, in the sense that it is a binary tree whose leaves store hashes and whose nodes who are not leaves are the hash of the concatenation of its children values. However, contrarily to a Merkle Tree, a MMR is not necessarily (and is often not) balanced. Plus, the hashes that the leaves store aren't transaction hashes, but block headers hashes: the first leaf stores the hash of the Genesis header, the second the one of the second block, etc.
                    
                    The idea behind MMR is also very similar to a Merkle Tree: given the root of the MMR, it is computationally infeasible to create hashes to make the verifier believe that one node is within the MMR when it isn't. In the \FC\ protocol, the interlink data in a block is the MMR root of the MMR committing all the previous blocks of the chain \cite{\FCCite}. For instance, the genesis has an empty interlink data field, the second block has the hash of the genesis header in its interlink data, etc.
                    
                    In order to build a MMR with \(n\) leaves and root \(r\), two additional properties have to be verified according to \cite{\FCCite}:
                    
                    \begin{itemize}
                        \item its depth is \(\left\lceil\log_2(n)\right\rceil\);
                        \item \(r\).left is a MMR with \(2^{1+\left\lceil\log_2(n)\right\rceil}\) leaves, while \(r\).right is a MMR with \(n-2^{1+\left\lceil\log_2(n)\right\rceil}\) leaves.
                    \end{itemize}
                    
                    More simply, if \(i\) is the biggest integer such that \(n\) can be decomposed as \(n=2^i+j\), then the leftmost part of the MMR is a MMR with \(2^i\) leaves, while the rightmost of the MMR is a MMR with \(j\) leaves. An example of a MMR is given in \autoref{figure:mmrconstruct}.
                
                \begin{figure}[ht]
                    \centering
                    \begin{forest}
                        [MMR root
                            [\(H\left(H\left(H\left(h_1\middle|h_2\right)\middle|H\left(h_3\middle|h_4\right)\right)\middle|H\left(H\left(h_5\middle|h_6\right)\middle|H\left(h_7\middle|h_8\right)\right)\right)\)
                                [\(H\left(H\left(h_1\middle|h_2\right)\middle|H\left(h_3\middle|h_4\right)\right)\),tier=3
                                    [\(H\left(h_1\middle|h_2\right)\)
                                        [\(h_{1}\), tier=1]
                                        [\(h_{2}\), tier=1]
                                    ]
                                    [\(H\left(h_3\middle|h_4\right)\)
                                        [\(h_{3}\), tier=1]
                                        [\(h_{4}\), tier=1]
                                    ]
                                ]
                                [\(H\left(H\left(h_5\middle|h_6\right)\middle|H\left(h_7\middle|h_8\right)\right)\),tier=3
                                    [\(H\left(h_5\middle|h_6\right)\)
                                        [\(h_{5}\), tier=1]
                                        [\(h_{6}\), tier=1]
                                    ]
                                    [\(H\left(h_7\middle|h_8\right)\)
                                        [\(h_{7}\), tier=1]
                                        [\(h_{8}\), tier=1]
                                    ]
                                ]
                            ]
                            [\(H\left(H\left(h_9\middle|h_{10}\right)\middle|h_{11}\right)\),tier=3
                                [\(H\left(h_{9}\middle|h_{10}\right)\)
                                    [\(h_{9}\), tier=1]
                                    [\(h_{10}\), tier=1]
                                ]
                                [\(h_{11}\),tier=1]
                            ]
                        ]
                    \end{forest}
                    \caption{A MMR with 11 leaves}
                    \label{figure:mmrconstruct}
                \end{figure}
                    
                    Now that MMR are well defined, it is easy to add a leaf to it to build a new MMR. This algorithm has been written in \cite{\FCCite}. Plus, it is easy for a prover to provide the proof \(\Pi_k\) that the block number \(k\), whose hash is known, is within the MMR. Indeed, the method is exactly the same as the one for Merkle Tree, and hence as secure.
                \subsubsection{The \FC\ protocol}
                    The \FC\ protocol assumes that a client, the verifier, is connected to at least two provers, amongst which at least one is honest. The goal of \FC\ is to check whether a certain transaction TX is included in a certain block \(B\) which lies within the main chain. Since the proof of inclusion of TX within \(B\) is easily done with Merkle Tree proofs, the goal of the \FC\ protocol is to determine whether \(B\) is in the chain.
                    
                    Hence, the client will ask both provers to provide a MMR proof that \(B\) lies within the main chain, along with the length of their chain and the header of their last known block. If both provers agree, then they are honest and the protocol ends. If not, one of them is not honest. The \FC\ client then proceeds in two steps:
                    
                    \begin{enumerate}
                        \item It asks the provers for inclusion proofs of blocks according to an optimal random sampling.
                        \item It asks for an inclusion proof of \(B\) if the previous step has not failed.
                    \end{enumerate}
                    
                    Note that during the second step, the client now trusts the prover the owns a copy of the valid chain. Hence, the second step is the one that determines the outcome of the protocol. Furthermore, note that this protocol is inherently non-interactive: the clients asks for all the block it wants in one go.
                    
                    Let us imagine that an adversary wants to perform a double-spent transaction: their goal is to fool the client into believing a block lies in the chain while it does not. Since a honest miner will also answer and claim having a chain of length \(n\), the adversary is also forced to do so. Indeed, the client would check the honest chain first otherwise, and then consider it as the valid chain without even considering the adversary's. But since the adversary have less computational power than the set of all honest miners, they would be forced to include fake blocks in their fork, that are blocks without a valid PoW. The situation  is represented in \autoref{figure:fcusecase}. Fake blocks are drawn in red.
                    
                    \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}[decoration={snake}]
                        \node[block] (G) {};
                        \node[below of=G] {$G$};
                        \node[block, right=of G] (c) {};
                        \node[below of=c] {$c$};
                        \node[block, above right=of c] (cprime1) {};
                        \node[below of=cprime1] {$(c+1)'$};
                        \node[block, below right=of c] (c1) {};
                        \node[below of=c1] {$c+1$};
                        \node[block, right=of cprime1,fill=red!20] (cprime2) {};
                        \node[below of=cprime2] {$(c+2)'$};
                        \node[block, right=of cprime2,fill=red!20] (cprimej) {};
                        \node[below of=cprimej] {$(c+j)'$};
                        \node[block, right=of c1] (c2) {};
                        \node[below of=c2] {$c+2$};
                        \node[block, right=of c2] (c3) {};
                        \node[below of=c3] {$c+j$};
                        
                        \path[draw, decorate] (G) -- (c);
                        \path[draw] (cprime1.west) -- (c.north);
                        \path[draw] (c1.west) -- (c.south);
                        \path[draw] (cprime1.east) -- (cprime2.west);
                        \path[draw] (c1.east) -- (c2.west);
                        \path[draw,decorate] (c2.east) -- (c3.west);
                        \path[draw,decorate] (cprime2.east) -- (cprimej.west);
                    \end{tikzpicture}
                    \caption{\FC\ use case}
                    \label{figure:fcusecase}
                \end{figure}
                
                    The goal of the adversary is that none of their fake blocks are sampled. Since the more they wait, the more fake blocks they have to add to their fork, thry want their fork to be as short as possible. Hence, the goal now for \FC\ is to find the optimal random sampling, which will surely sample recent blocks more often. For this, a piece of information is crucial: \FC\ has been designed to be implemented as a soft fork. Hence, every block that is mined on top of the chain is to have a valid interlink data. Since an inconsistency between the interlink data of a block and the true MMR root can be easily detected, an adversary has no way to put arbitrary data in the interlink field of a block they have mined.
                    
                    Since the client will first verify (and potentially trust) provers with longer chains, an adversary that wants to perform a double-spent transaction has no choice but to fork the main chain and add fake blocks (that are blocks without a valid PoW) within its fork to equal the length of the main chain. The \FC\ protocol is thus to sample blocks randomly within the chain and to stop if a fake block is sampled.
                    
                    An important piece of information is to be understood in order to understand the \FC\ protocol: if the prover is asked for block \(k\) (or more precisely, for a proof of inclusion of block \(k\)), it cannot provide another block instead. Indeed, because of the way the MMR has been built, and since the prover already has sent its MMR root, changing block positions while keeping the same MMR root is computationally infeasible, since the hash function that is used is believed to be pre-image resistant.
                    
                    Using these information, \citeauthor{\FCCite} found out that an optimal sampling distribution samples more frequently recent blocks than older blocks. Plus, they have been able to determine the optimal sampling strategy using these information. Regarding to this project, it is very important to understand how things implied others. Because of the fact that \FC\ was deployed on a soft/hard fork, the only thing an adversary can do is try to create a fork of the same length as the main chain, and because of this, an optimal sampling distribution could be found.

        \section{Updating the protocol rules}
            In order to implement \FC\ protocol, it is necessary to either start a blockchain that accepts a MMR interlink data from the start, or to update the protocol according to which miners have to mine blocks. Since it will not be reasonable to start the Bitcoin blockchain from the start, only the latter is possible. In this section, we aim to describe what are the possibilities for updating a PoW blockchain so that \FC\ can be implemented on it. In the general case, let us consider that a blockchain running protocol \(\mathcal{P}\) wants to implement protocol \(\mathcal{P}'\). The set of valid blocks is thus transformed from \(\mathcal{V}\) to \(\mathcal{V}'\).
            \subsection{Traditional forks}
                A first solution could be to implement \FC\ either as a hard fork or as a soft fork.
                \subsubsection{Hard fork}
                    According to \cite{Velvet}, if \(\mathcal{V}\subset\mathcal{V}'\), then if the majority of miners are updated this will be called a hard fork. A hard fork expands the set of validity blocks, thus making old blocks compatible with the new protocol, but new blocks incompatible with the old protocol. A hard fork transforms previously invalid blocks into valid ones.
                    
                    An example of such a fork would the increase of the allowed block size from \(s\) to \(s'\), that is \(s'>s\). According to the upgraded miners, every block with a size lower than \(s'\) is valid, which is true for every block mined before the protocol was implemented, since its size is \(s\).
                    
                    In the case of the \FC\ protocol, \citeauthor{\FCCite} proposed to implement \FC\ as a hard fork. This would imply that MMR root would not only be added to future blocks, but also that they would be computed and added to already mined blocks. Fundamentally, this is basically the same as starting a new blockchain that accepts MMR root from the client point of view. The difference is that starting all from the beginning isn't required anymore here. This assumes that a majority of miners are upgraded, so that the consensus uses the new protocol.
                \subsubsection{Soft fork}
                    Another possibility is what is called a soft fork. Instead of expanding the validity set \(\mathcal{V}\), the new protocol reduces it, that is \(\mathcal{V}'\subset\mathcal{V}\). Hence, the new blocks are compatible with the old protocol, but the old blocks aren't compatible anymore with the new protocol. This is for instance the case when the new protocol reduces the size of blocks. Contrarily to hard fork, a soft fork is really one only whenever a majority of nodes have adopted the new protocol rules \cite{Velvet}.
                    
                    In the case of the \FC\ protocol, this means that the MMR roots would only be added to blocks mined after the protocol update.
            \subsection{Velvet forks}
                While hard and soft forks are the most classical cases of forks, a more recent one have some advantages that they don't: the so-called velvet fork \cite{Velvet}.
                
                When a new protocol is deployed as a velvet fork, upgraded and non-upgraded miners work hand in hand. A block is valid only if it is valid according to the old protocol \(\mathcal{P}\). Additionally, upgraded miners mine blocks according to the new protocol \(\mathcal{P}'\). Hence, the set of validity blocks is the same in both cases: \(\mathcal{V}=\mathcal{V}'\) \cite{Velvet}. The main advantage is that even if a small proportion \(g\) of miners are upgraded, it may still be possible to use the protocol \(\mathcal{P}'\) by taking into account that there is the possibility that some blocks won't contain a MMR root.
                
                This approach was also considered by \citeauthor{\FCCite}. In the case of a deployment on a velvet fork, upgraded miners would, in a backward compatible way, include the MMR root in their blocks, while non-upgraded miners won't. Crucially, this also means that a block with random (and thus, invalid) data in the interlink data field would also be accepted by the consensus: every miner can put whatever they want in this field. It is shown in \cite{\FCCite} that it leads to less efficient proofs: the proof size is larger by a factor of \(\frac1g\) in this case. Such blocks, with invalid (or empty) interlink data field are called legacy blocks.
    \chapter{Progress}
        In this section, we aim to describe the progress that was made on the problematic so far.
        \section{\textit{Chain-sewing} attacks}
            A personal correspondence with Andrianna Polydouri and Dionysis Zindros showed that the Superblock protocol is prone to be attacked with what is called a \textit{chain-sewing} attack. Such an attack is applicable when the new protocol is deployed as a velvet fork.
            
            The idea is that the adversary can put arbitrary data in the interlink field. Hence, they can put interlink data that is invalid for honest miners but that may be considered valid by the verifier. Such an attack on \FC\ is described in \autoref{subsection:attack}.
        \section{Principle of a \textit{chain-sewing} attacks on \FC}
            \label{subsection:attack}
            Let us place ourselves within the Bitcoin backbone protocol with variable difficulty. Let us assume that the \FC\ protocol was implemented on a velvet fork in this context. In particular, this means that:
            
            \begin{itemize}
                \item every block header contains a reference to the previous block in the chain, since it has to be valid according to the old protocol, be it a Proof of Work or a Proof of Stake;
                \item it is possible for a prover to indicate a block as a legacy block. Otherwise, every miner who puts random data in the MMR root field will break the protocol as no proofs sampling this block would be accepted;
                \item a block header can contain arbitrary data in the MMR root field;
                \item if a legacy block is sampled, the prover must provide all its ancestors until the most recent upgraded block.
            \end{itemize}
            
            Let us assume that at a block \(c\) of the main chain \(\mathsf{C}\), the adversary creates a fork. In the mean time, both the honest miners and potentially the adversary continue to mine on top of the main chain. In order to do so, the adversary splits its computational power so that they mine on top of the fork with a portion \(\beta\) of its computational power and uses the rest to mine on top of the main chain. The adversary will behave according to the \FC\ protocol on both the fork and the main chain. Honest miners will continue to behave accordingly to the \FC\ protocol. The situation is represented on \autoref{figure:chainsewingattempt}, where black blocks are mined by the adversary and contains a MMR root and dashed arrows corresponds to a MMR link if it is different from the previous block header hash reference.
        
            \begin{figure}[ht]
                \centering
                    \begin{tikzpicture}[decoration = {snake}]
                        \node[block] (G) {};
                        \node[below of=G] {$G$};
                        \node[block, right=of G] (c) {};
                        \node[below of=c] {$c$};
                        \node[block, above right=of c,fill=black] (cprime1) {};
                        \node[below of=cprime1] {$(c+1)'$};
                        \node[block, below right=of c] (c1) {};
                        \node[block, right=of cprime1,fill=black] (cprimei) {};
                        \node[below of=cprimei] {$(c+i)'$};
                        \node[below of=c1] {$c+1$};
                        \node[block, right=of c1] (cj) {};
                        \node[below of=cj] {$c + j$};
                        \node[block, above right=of cj, fill=black] (cj1) {};
                        \node[below of=cj1] {$c + j + 1$};
                        \node[block, right=of cj1] (k) {};
                        \node[below of=k] {$k$};
                        \node[block, right=of k,fill=black] (k1) {};
                        \node[below of=k1] {$k + 1$};
                        \node[block, right=of k1] (N) {};
                        \node[below of=N] {$N$};
                        
                        \path[draw, decorate] (G) -- (c);
                        \path[draw] (cprime1.west) -- (c.north);
                        \path[draw] (c1.west) -- (c.south);
                        \path[draw, decorate] (cprime1) -- (cprimei);
                        \path[draw, decorate] (c1) -- (cj);
                        \path[draw, dashed, ->] (cj1.north) -- (cprimei.east);
                        \path[draw] (cj1.south) -- (cj.east);
                        \path[draw, decorate] (cj1) -- (k);
                        \path[draw] (k) -- (k1);
                        \path[draw,decorate] (k1) -- (N);
                    \end{tikzpicture}
                    \caption{A chainsewing attack attempt on \FC}
                    \label{figure:chainsewingattempt}
                \end{figure}
            
            Starting from \(c+j+1\), which we will call the \textit{merging block} from now on, every block mined by the adversary will contain a MMR root corresponding to the MMR where the portion \(\mathsf{C}[c+1:c+j]\) has been replaced with the adversary's fork, and where all honest miner's blocks are considered as legacy blocks. Once in this situation, a number \(N-c-j-1>k\) of blocks are mined on top of \(c+j+1\). In order to have, let say, \((c+1)'\) accepted, the adversary must:
            
            \begin{itemize}
                \item convince the verifier that they holds a chain \(\mathsf{C}'\) that is as long as the main chain;
                \item provide the verifier with a MMR proof that \((c+1)'\) lies within \(\mathsf{C}'\).
            \end{itemize}
            
            Let us focus on the latter for now. As a recall, the adversary blocks and an honest miner's now have different MMR roots, and both considers the other's blocks as legacy blocks. For this reason, it is necessary for a prover to have the capacity to designate a sampled block as legacy. Otherwise, whenever an adversary's block is mined, the proof provided by an honest miner will fail.
            
            Hence, it is possible for the adversary to designate any honest miner's block as a legacy block, so that only adversarial blocks are sampled. Because of the way the adversary has built its MMR, they will succeed in proving the inclusion of \((c+1)'\) in the chain the adversary claims to have.
            
            However, the adversary still has to prove that the MMR root in \((c+1)'\) belongs to a chain of the same length as the main chain, that is to prove that the chain they claims to have is the longest chain they know. Indeed, two cases are possible:
            
            \begin{enumerate}
            \item The verifier only connects to the adversary.
            \item The verifier connects to at least one honest prover.
            \end{enumerate}
            
            The first case is actually trivial: since the verifier has no other information than the ones provided by the adversary, the adversary will succeed in proving that she holds the longest chain, since there is no other chain anyway.
            
            The second case is more difficult. An honest prover will tell the verifier that they hold a chain of length \(n\). Since longer chains will be verified first, the adversary also has to claim having a chain of length \(n\), while only having a chain of length \(n-j+i\). \FC\ has been built for preventing this very situation. Hence, the only way for the adversary to succeed is to set \(j=i\). The best strategy is then to try to mine \(c_x'\) while \(c_x\) is mined on the main chain for some \(x\). If \(c_x'\) is mined before \(c_x\), the adversary begins to mine \(c_{x+1}'\). If it is not, the adversary places a fake block at place \(x\) and begins to mine \(c_{x+1}'\). Note that even if the adversary have some advance, they have to wait until the corresponding block is mined for mining the merging block. For simplicity, let us take \(j=i=1\). This corresponds to the situation in \autoref{figure:chainsewingattack}.
            
            \begin{figure}[ht]
                \centering
                    \begin{tikzpicture}[decoration = {snake}]
                        \node[block] (G) {};
                        \node[below of=G] {$G$};
                        \node[block, right=of G] (c) {};
                        \node[below of=c] {$c$};
                        \node[block, above right=of c] (cprime1) {};
                        \node[below of=cprime1] {$(c+1)'$};
                        \node[block, below right=of c] (c1) {};
                        \node[below of=c1] {$c+1$};
                        \node[block, above right=of c1, fill=black] (c2) {};
                        \node[below of=c2] {$c + 2$};
                        \node[block, right=of c2] (k) {};
                        \node[below of=k] {$k$};
                        \node[block, right=of k,fill=black] (k1) {};
                        \node[below of=k1] {$k + 1$};
                        \node[block, right=of k1] (N) {};
                        \node[below of=N] {$N$};
                        
                        \path[draw, decorate] (G) -- (c);
                        \path[draw] (cprime1.west) -- (c.north);
                        \path[draw] (c1.west) -- (c.south);
                        \path[draw, dashed, ->] (c2.north) -- (cprime1.east);
                        \path[draw] (c2.south) -- (c1.east);
                        \path[draw, decorate] (c2) -- (k);
                        \path[draw] (k) -- (k1);
                        \path[draw,decorate] (k1) -- (N);
                    \end{tikzpicture}
                    \caption{A chainsewing attack attempt on \FC\ with a fork of length 1}
                    \label{figure:chainsewingattack}
                \end{figure}
                
            Now, it is easy for the adversary to claim having a chain of length \(n\). Actually, they can even claim having a longer chain if they manage to mine a block at the top of the chain and by keeping it secret from the honest miners for a time. The advantage of doing this is that \FC\ will begin by the longer proof, that is the adversary's.
            
            However, is is crucial that \(c+2\) is not sampled when proving this. Indeed, an inconsistency between its PoW (or more generally, its reference to the previous block) and its MMR will be revealed. Indeed, the verifier is able to know that \((c+1)'\) and \(c+2\) are supposed to be adjacent, according to the MMR structure they deduced from \(n\), that the adversary had to provide. Since the adversary wants \((c+1)'\) to be verified, they will have to send it to the prover. Hence, if \(c+2\) is sampled by the client, then an inconsistency between the MMR root and the previous block can be detected by the client.
            
            Note that this case is not actually described in the \FC\ paper. Hence, if \FC\ is deployed without taking this problem into account, the probability of succees, as computed in \autoref{subsection:probability} increases. 
            
            A solution for the adversary to avoid this is simply to wait for blocks being mined on top of the main chain. Indeed, the current design of \FC\ makes old blocks less-likely to be sampled. Hence, by doing so, it is high-likely that \(c+2\) won't be sampled, and that no inconsistency will be detected when the adversary will send \((c+1)'\).
            
            In order to circumvent this problem, one may also try to introduce intermediary blocks, valid or not, between \((c+1)'\) and \(c+2\). However, since the fork of the adversary has to be of the same length as the corresponding chain portion, the same problem will happen: an inconsistency will be detected between the previous block reference and the MMR root. Indeed, let us consider the situation depicted in \autoref{figure:chainsewingdouble}.
            
            \begin{figure}[ht]
                \centering
                \begin{tikzpicture}[decoration = {snake}]
                    \node[block] (G) {};
                    \node[below of=G] {$G$};
                    \node[block, right=of G] (c) {};
                    \node[below of=c] {$c$};
                    \node[block, above right=of c] (cprime1) {};
                    \node[below of=cprime1] {$(c+1)'$};
                    \node[block, below right=of c] (c1) {};
                    \node[block, above right=of cprime1] (cprime2bis) {};
                    \node[below of=cprime2bis] {$(c+2)'$};
                    \node[block, below right=of cprime1,fill=black] (cprime2) {};
                    \node[below of=cprime2] {$c+2$};
                    \node[below of=c1] {$c+1$};
                    \node[block, right=of c1] (c2) {};
                    \node[below of=c2] {$c + 2$};
                    \node[block, above right=of c2, fill=black] (c3) {};
                    \node[below of=c3] {$c + 3$};
                    \node[block, right=of c3] (k) {};
                    \node[below of=k] {$k$};
                    \node[block, right=of k,fill=black] (k1) {};
                    \node[below of=k1] {$k + 1$};
                    \node[block, right=of k1] (N) {};
                    \node[below of=N] {$N$};
                    
                    \path[draw, decorate] (G) -- (c);
                    \path[draw] (cprime1.west) -- (c.north);
                    \path[draw] (c1.west) -- (c.south);
                    \path[draw] (cprime1) -- (cprime2);
                    \path[draw] (cprime1) -- (cprime2bis);
                    \path[draw] (c1) -- (c2);
                    \path[draw, dashed, ->] (c3.north) -- (cprime2bis.east);
                    \path[draw] (c3.south) -- (c2.east);
                    \path[draw, decorate] (c3) -- (k);
                    \path[draw] (k) -- (k1);
                    \path[draw,decorate] (k1) -- (N);
                \end{tikzpicture}
                \caption{A try to prevent the merging block sampling problem}
                \label{figure:chainsewingdouble}
            \end{figure}
                
            The solution works as follows:
            
            \begin{itemize}
                \item if \(c+3\) is not sampled, there is no problem;
                \item if \(c+3\) is sampled, then the adversary has to build a MMR where the hash at place \(c+2\) is \(c+2's\) hash.
            \end{itemize}
            
            The adversary wants to convince the verifier that \((c+1)'\) is within the chain, but they has no control over the values of the leaves number \(c+1\), which contains the hash of \((c+1)'\) and \(c+2\), which contains the hash of \(c+2\). Hence, the only thing they has control on is the MMR proof they send. What the adversary has to do is to create a MMR proof so that the hashes they send add up to the MMR root in \(c+3\). However, it means that the adversary has to find a hash so that everything adds up correctly to the MMR root. Since the hash function used is believed to be pre-image resistant, this is computationally infeasible. Plus, a sampling where both \(c+3\) and \(c+2\) are sampled would also reveal an inconsistency.
            
            Getting back to the \textit{chain-sewing attack}, the reason why this works on a velvet fork only is that an adversary is allowed to put some Fake MMR root in a block header of the main chain. In particular, the following was outlined in the \FC\ paper: \enquote{once a malicious prover forks off from the honest chain, it cannot include any of the later honest blocks in its chain because the MMR root in those blocks would not match the chain} \cite{\FCCite}.
            
            In particular, the adversary is not forced to create a fork as long as the main chain, eventually creating fake blocks. We may note that this attack works as long as the fork created by the adversary is as long as the corresponding chain portion. The adversary can also include fake blocks in its fork to have a longer fork while sticking to this constraint. Even though this increases the probability of getting caught as every fake block sampled results in a failed proof, waiting long enough once the fork has been merged is enough for hoping that these blocks won't be sampled. Hence, the attack also works with longer forks.
            
        \section[Probability of success]{Probability of success of the \textit{chain-sewing} attack on \FC}
            \label{subsection:probability}
            In order for the attack to succeed, the only thing that is needed is that neither the merging block is sampled nor are the fake blocks in the fork, and that the adversary manages to mine at least one block, that is the merging one. Hence, two things are to be considered:
            
            \begin{enumerate}
            \item the probability for the attacker to mine the merging block;
            \item the probability for the merging block to be sampled.
            \end{enumerate}
            
            Note that the computations are done for a constant difficulty for now, but similar ones can be done for taking into account variable difficulty.
            
            \subsection{Probability for the attacker to mine the merging block}
                If the adversary manages to mine the forking block before a honest miner mines the corresponding honest block, then the adversary has a probability \(\alpha\) of mining the forking block, since a ratio \(\alpha\) of the blocks are mined by the adversary. For a fork of length \(f\), the adversary has in average to place \(k=(1-\alpha)\,f\) fake blocks in it. Following the strategy of giving up on a block (hence placing a fake one) as soon as the corresponding honest block is mined, the probability of creating a fork of length \(f\) is \(\alpha\), since it is the probability of mining the merging block one the fork is of length \(f\).
                
                In order not to have lost computational power, the adversary can, if they doesn't mine the merging block, try to add a fake block to the fork and try again to mine the merging block. This doesn't impact the probability of success of this part, but impact the one of getting caught. In average, following this strategy, the adversary will add \(\frac{1-\alpha}{\alpha}\) fake blocks to the fork.
            \subsection{Probability for the merging block or fake blocks to be sampled under a constant difficulty}
                Let us assume that:
                \begin{itemize}
                    \item the chain has a total of \(n\) blocks;
                    \item the merging block is at position \(m\) in the chain;
                    \item \((x_1,\cdots,x_k)\) are the increasing positions of the fake blocks in the fork.
                \end{itemize}
                
                The adversary succeeds if neither \(m\) nor any of the \(x_i\) is sampled. The former is due to the fact that its reference to the previous block is inconsistent with its MMR root, while the latter just have invalid PoWs. The probability that a block at position \(x>n - L\) is sampled is 1, while the probability that a block at position \(x\leqslant n-L\) is:
                
                \begin{align*}
                    p_x &= \frac{1}{\ln\left(\frac{L}{n}\right)}\int_{\frac{x}{n}}^{\frac{x+1}{n}}\frac{\mathrm{d}t}{t-1}\\
                    &= \frac{\ln\left(\left|\frac{x+1}{n}-1\right|\right)-\ln\left(\left|\frac{x}{n}-1\right|\right)}{\ln\left(\frac{L}{n}\right)}\\
                    &= \frac{\ln\left(1-\frac{1}{n-x}\right)}{\ln\left(\frac{L}{n}\right)}\\
                    &= \frac{\ln\left(1+\frac{1}{n-x-1}\right)}{\ln\left(\frac{n}{L}\right)}
                \end{align*}
                
                Hence, the probability of the adversary not succeeding is:
                
                \begin{align*}
                    p_{\text{failure}} &= p_m + \sum_{i=1}^kp_{x_i}\\
                    &\leqslant p_m + \sum_{i=1}^kp_m\\
                    &= \frac{k+1}{\ln\left(\frac{n}{L}\right)}\,\ln\left(1+\frac{1}{n-m-1}\right)
                \end{align*}
                
                For a fork of length \(f\), the adversary has in average to place \(k=(1-\alpha)\,\left(f+\frac{1}{\alpha}\right)\) fake blocks in it. In order to mine the merging block, they also has to put \(F\) fake blocks at the end of the fork, where \(F\) follows a geometric distribution of parameter \(\alpha\). Hence, the probability that the adversary makes the verifier believe that a fork of length \(f\) is within the main chain, starting at block \(m-f\), assuming that the adversary owns a fraction \(\alpha\) of the total computational power and that it is subject to the \((c,L)\)-assumption is at least, in average:
                
                \[\alpha\,\left[1-\frac{1+(1-\alpha)\,\left(f+\frac1\alpha\right)}{\ln\left(\frac{n}{L}\right)}\,\ln\left(1+\frac{1}{n-m-1}\right)\right]\]
                
                If the adversary is only interested in making a double-spent transaction, they doesn't has to place any fake blocks (since the transaction block will be sampled, it can't be fake). The probability of succeeding is then at least:
                
                \[\alpha^2\,\left[1-\frac{\ln\left(1+\frac{1}{n-m-1}\right)}{\ln\left(\frac{n}{L}\right)}\right]\]
                
                More generally, the probability of the adversary having a fork of length \(f\) without putting any fake blocks is at least:
                
                \[\alpha^{f+1}\,\left[1-\frac{\ln\left(1+\frac{1}{n-m-1}\right)}{\ln\left(\frac{n}{L}\right)}\right]\]
                
                However, the way that \FC is designed allows the adversary to submit another proof if one doesn't succeed because of the sampling. Caching the fake sampled blocks can be a solution for the client, but it is not scalable. Hence, the way \FC is designed, the probability of success of the adversary is equal to the probability of getting caught, that is, for a fork of length \(f\) with fake blocks:
                
                \[1-\frac{1+(1-\alpha)\,\left(f+\frac1\alpha\right)}{\ln\left(\frac{n}{L}\right)}\,\ln\left(1+\frac{1}{n-m-1}\right)\]
                
                and for a fork of length \(f\) without fake blocks:
                
                \[1-\frac{\ln\left(1+\frac{1}{n-m-1}\right)}{\ln\left(\frac{n}{L}\right)}\]
                
                Finally, note that if \FC\ is implemented without taking into account the fact that the previous block reference and the MMR root can reveal an inconsistency, it will accept the adversary's chain even if the merging block is sampled. Then, the probability of success for creating a double-spent transaction is \(\alpha^2\), since the adversary only has to mine the forking block and the merging one.
            \subsection{Probability for the merging block or fake blocks to be sampled using the Bitcoin protocol}
                \FC\ can be implemented to work on a blockchain with a variable difficulty, like the Bitcoin one. The velvet fork attack works just the same as in the constant difficulty case. However, the probability of an attacker succeeding in running a velvet fork attack slightly decreases.
                
                Indeed, the previous analysis considers the input space \([0\,;\,1]\) of the distribution function as a variable that ranges over blocks. For instance, \(x=\frac12\) roughly corresponds to the block at position \(\frac{n}{2}\) in the blockchain. However, as described in \cite{\FCCite}, one can adapt \FC\ to work with variable difficulty by considering \([0\,;\,1]\) as a variable that ranges over the difficulty. For instance, \(x=\frac{1}{2}\) roughly corresponds to the block where \(\frac12\) of the total computational power has been mined. This is actually a generalization of the previous process: under a constant difficulty, half of the total computational power has been spent roughly at block \(\frac{n}{2}\).
                
                Using data from \cite{BTCDifficulty}, we can plot the graph of the Bitcoin difficulty over time, using \([0\,;\,1]\) as an space that ranges over blocks, which is shown on \autoref{figure:diff1}.
                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}
                        \begin{axis}[ylabel={Difficulty}, no marks]
                            \addplot table[x index=0, y index=1] {data/difficulty.txt};
                        \end{axis}

                    \end{tikzpicture}
                    \caption{Difficulty of the Bitcoin protocol}
                    \label{figure:diff1}
                \end{figure}
                
                However, what we're interested in is the cumulated difficulty over time, which is shown on \autoref{figure:diff2} and which we denote \(d\).
                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}
                        \begin{axis}[xlabel={Block position},ylabel={Cumulated difficulty}, no marks]
                            \addplot table[x index=0, y index=1] {data/cumulated_difficulty.txt};
                        \end{axis}

                    \end{tikzpicture}
                    \caption{Cumulated difficulty of the Bitcoin protocol}
                    \label{figure:diff2}
                \end{figure}
                
                Since what we essentially want is to translate a variable that ranges over the block space to a variable, we denote \(d\) such a function. Hence, the resulting sampling distribution \(s\) is \(x\in[0\,;\,1]\mapsto\frac{1}{(d(x) - 1)\,\ln\left(\frac{n}{L}\right)}\). Still, we have to have \(\int_0^{1-\delta}s(x)\,\mathrm{d}x=1\). Hence, the final sampling distribution \(s\) is:
                
                \[\forall x\in[0\,;\,1-\delta],s(x)=\frac{1}{[d(x)-1]\,\int_{0}^{1-\delta}\frac{\mathrm{d}x}{d(x)-1}}\]
                
                \autoref{figure:d} represents the graph of \(d\), while \autoref{figure:s} represents the final sampling distribution compared to the previous one.
                                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}
                        \begin{axis}[xlabel={Cumulated difficulty}, ylabel={Block position}, no marks]
                            \addplot table[x index=1, y index=0] {data/cumulated_difficulty.txt};
                        \end{axis}

                    \end{tikzpicture}
                    \caption{Graph of \(d\)}
                    \label{figure:d}
                \end{figure}
                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}
                        \begin{axis}[xlabel={Block position}, no marks, legend entries={Variable difficulty, Constant difficulty},legend style={at={(0,1)},anchor=north west}]
                            \addplot table[x index=0, y index=1] {data/sampling_bitcoin.txt};
                            \addplot table[x index=0, y index=2] {data/sampling_bitcoin.txt};
                        \end{axis}

                    \end{tikzpicture}
                    \caption{Comparison between the sampling distribution in the constant difficulty case and the one in the variable difficulty case for \(\delta=2^{-10}\)}
                    \label{figure:s}
                \end{figure}
                
                The difference between these two functions being small, it may be more convenient to represent the difference between these two, which is shown on \autoref{figure:difference}.
                
                \begin{figure}[ht]
                    \centering
                    \begin{tikzpicture}
                        \begin{axis}[xlabel={Block position}, no marks,grid=major]
                            \addplot table[x index=0, y index=1] {data/difference.txt};
                        \end{axis}

                    \end{tikzpicture}
                    \caption{Difference between the sampling distribution in the variable difficulty case and the one in the constant difficulty case for \(\delta=2^{-10}\)}
                    \label{figure:difference}
                \end{figure}

        \section{Mitigating the \textit{chain-sewing} attack on \FC}
            The probability that the \textit{chain-sewing} attack succeeds has been computed in the case where \FC\ is implemented as defined in \cite{\FCCite}. In particular, it uses the fact that \FC\ samples more frequently recent blocks than old ones to maximize the probability of success.
            
            The thing is, since the adversary can now merge its fork to the main chain from the MMR point of view, it is not true that this strategy is optimal anymore. The fork can be both very short and very old, which wasn't the case when \FC\ is deployed as a soft fork or as a hard fork.
            
            A solution to tackle this problem may be to use the Binary Search Approach, as described in \cite{\FCCite}. However, because of the fact that this approach is interactive, it may lead to additional delays. Plus, this approach is deterministic. Hence, the adversary knows in advance which blocks will be sampled. In spite of this, it may be still impossible for an adversary to perform a double-spent transaction, but this is to be proved formally.
    \printbibliography
\end{document}
